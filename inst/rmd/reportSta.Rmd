---
title: "Single Trial Analysis Report"
author: "Contact:<a href = 'https://github.com/Breeding-Analytics/bioflow' target = '_blank'>Breeding Analytics Team, OneCGIAR</a> breedinganalytics@cgiar.org"
date: "`r format(Sys.time(), '%B %d, %Y')`"  
output: html_document
params:
  toDownload: FALSE
---


```{r setup, include=FALSE}
# knitr R markdown chunk options
knitr::opts_chunk$set(dependson = knitr::all_labels(),
                      echo = FALSE,
                      cache = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      comment = NA,
                      out.width = "100%",
                      error = TRUE)
options(knitr.kable.NA = '')
# loading necessary R packages ####
## data manipulation
# library(dplyr)    # %>%, data cleaning functions
library(magrittr) # coerce col to factors or numeric
## outputs - graphs, tables
library(ggplot2)  # ggplot(), etc.
library(plotly)  # ggplot(), etc.
library(DT)       # datatable()
library(knitr)    # kable
library(data.table)
library(shiny)
```

```{r printfxn, include=FALSE}
# functions ####

# for printing tables (data.frames) - DT::datatable()
printTable <- function(DT, pageLength = 7, 
                         numericColNames = NULL, numRound = 3, 
                         scrollXOpt = FALSE, colNames = NULL, autoWidthOpt = FALSE,...) {
    oldnames <- colnames(DT)
    DT <- data.frame(lapply(X = DT, 
                            FUN = function(x) {
                              if(is.numeric(x)){
                                round(x, numRound)
                              } else {
                                x
                              }
                            }))
    colnames(DT) <- oldnames
    table <- DT::datatable(data = DT,
                           colnames = colNames,
                           filter = "top", 
                           options = list(autoWidth = autoWidthOpt,
                                          dom = 'l<<t>pB>', 
                                          buttons = c('copy', 'csv', 'excel', 'print'),
                                          pageLength = pageLength,
                                          searchHighlight = TRUE,
                                          lengthMenu = c(7, 14, 21, 28, 35),
                                          scrollX = scrollXOpt),
                           extensions = 'Buttons',
                           rownames = FALSE,
                           ...)
    if (length(numericColNames) > 0){
      table <- table %>% DT::formatRound(columns = numericColNames,
                                     digits = numRound)
    }
    
    table
  }
```

```{r, include=FALSE}
# Init Step to make sure that the dependencies are loaded
htmltools::tagList(printTable(mtcars))
htmltools::tagList(ggplotly(ggplot()))
# Get the current figure size in pixels:
get_w <- function() {
  with(knitr::opts_current$get(c("fig.width", "dpi", "fig.retina")),
       fig.width*dpi/fig.retina)
}

get_h <- function() {
  with(knitr::opts_current$get(c("fig.height", "dpi", "fig.retina")),
       fig.height*dpi/fig.retina)
}
```

### Objectives of Single-Trial Analysis

The objective of this dashboard is to help scientist to understand the following points:

1. Overall number of designations and environments included in the single trial analysis (input)

2. High-level summary statistics of the phenotypic information included (input)

3. Observed spatial variation in the different environments when coordinates of the field exist (input)

4. Genetic variance and other genetic parameters observed in the different environments for the different traits (output)

5. Individual adjusted means for each trait by environment combination (output)

6. Phenotypic correlation between environments for the traits present (output)

Understanding these data features should allow the scientist to identify trait by environments combinations that have enough genetic signal and take the decision of which to include in the multi-trial analysis. It should also allow the scientist to assess the quality of the trials conducted and take corrective measures (e.g., change service providers, improve practices, etc.).  


`r if(!is.null(result$data$weather)){"### Map of trials planted\n
The following map allows you to assess the location where trials are planted.\n"}`

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if(!is.null(result$data$weather)){ # if weather data was extracted
    yy <- result$metadata$weather
    yy <- yy[yy$parameter != "trait",]
    xx <- cgiarPipeline::summaryWeather(result)
    xx$trait <- cgiarBase::replaceValues(xx$trait, Search = yy$value, Replace = yy$parameter)
    xx <- xx[which( (xx$trait %in% c("latitude","longitude") ) & (xx$parameter == "mean") ),c("environment","trait","value")]
    xx <- reshape(xx, direction = "wide", idvar = "environment",
                  timevar = "trait", v.names = "value", sep= "_")
    colnames(xx) <- cgiarBase::replaceValues(colnames(xx), Search = c("value_latitude","value_longitude") , Replace = c("latitude","longitude") )
    
    if("params" %in% ls()){ # we will download the document
      
      world <- ggplot2::map_data("world")
      p <- ggplot2::ggplot() + # + 
        ggplot2::theme(legend.position="bottom", legend.text = ggplot2::element_text(size=4), legend.title = ggplot2::element_text(size=0)) +
        ggplot2::geom_map(
          data = world, map = world,
          ggplot2::aes(long, lat, map_id = region),
          color = "black", fill = "lightgray", linewidth=0.1
        )  + ggplot2::ylab(" Latitude") + ggplot2::xlab("Longitude") +
        ggplot2::geom_point(
          data = xx,
          ggplot2::aes(longitude, latitude, color = environment),
          alpha = 0.7
        ) 
      print(p)
      # plotly::ggplotly(p)
      
    }else{
      
      plotly::renderPlotly({
        
        fig <- xx
        fig <- fig %>%
          plotly::plot_ly(
            lat = ~latitude,
            lon = ~longitude,
            type = "scattermapbox",
            hovertext = ~environment, #us_cities[,"City"],
            marker = list(color = "fuchsia"))
        fig <- fig %>%
          plotly::layout(
            mapbox = list(
              style = 'open-street-map',
              zoom =1,
              center = list(lon = 0, lat = 0)
            )
          )
        # }
        fig
        
      })
      
    }
  }else{
    cat("No coordinates available. Skipping planting map.")
  }
  
}
```

### Entries and traits by environment table

The following table allows to see how many locations had data for the different traits. You may want to review if the phenotyping capacity can deal with the complexity of the trait (e.g., genotype by environment interaction) or if more resources should be deployed. Also you may want to check if you collected information from all the trials conducted.

<p>&nbsp;</p>

```{r, results='asis'}
suppressWarnings(tryCatch({
  if(file.exists("./outputs/resultSta.RData")){
    load("./outputs/resultSta.RData")
  }else{
    load("resultSta.RData")
  }
}, error = function(e) {
  shinyjs::hide()
}))

if (is.null(result)){
  
} else {
  
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  
  pred <- result$predictions
  pred <- pred[pred$analysisId == idSta,]
  traits <- unique(pred$trait)
  traits.env <- aggregate(designation ~ environment + trait, data = pred, FUN = length)
  traits.env <- reshape(data=traits.env, timevar = "trait", idvar = "environment", direction="wide")
  colnames(traits.env) <- gsub("designation.","",colnames(traits.env) )# c('environment',traits)
  summarySta <- as.data.frame(traits.env[,'environment'])
  for (i in 1:length(traits)){
    temp <- traits.env[,c('environment',traits[i])]
    colnames(temp)[2] <- "temp.col"
    temp <- as.data.frame(temp)
    j=i+1
    tempp=within(temp,{
      temp.col.n=NA
      temp.col.n[!is.na(temp.col)]='âœ… '
      temp.col.n[is.na(temp.col)]=''
    })
    temp <- tempp[,3]
    summarySta <- cbind(summarySta,temp)
  }
  colnames(summarySta) <- c('environment',traits)
  
  pheno <- result$data$pheno
  ### change column names for mapping
  paramsPheno <- result$metadata$pheno
  paramsPheno <- paramsPheno[which(paramsPheno$parameter != "trait"),]
  colnames(pheno) <- cgiarBase::replaceValues(colnames(pheno), Search = paramsPheno$value, Replace = paramsPheno$parameter )
  ###
  pheno.env <- pheno[,c('environment','designation')]
  pheno.env<- unique(pheno.env[c('designation','environment')]) 
  pheno.env.designation <-  aggregate(designation ~environment, data = pheno.env, FUN = length)
  colnames(pheno.env.designation)[2] <- "Number of designations"
  summarySta <- merge(x = summarySta, y = pheno.env.designation, by = "environment", all = TRUE)
  
  if("params" %in% ls()){ # we will download the document
    
    printTable(summarySta, autoWidthOpt = TRUE, scrollXOpt = FALSE,
             colNames = colnames(summarySta))
  }else{
    DT::renderDT(printTable(summarySta,
                        autoWidthOpt = FALSE, scrollXOpt = TRUE,
                        colNames = colnames(summarySta)), server = FALSE)
    # summarySta <- kableExtra::kbl(summarySta)
    # summarySta <-kableExtra::kable_styling(
    #   summarySta, 
    #   bootstrap_options = c("hover","condensed","responsive"), fixed_thead = T)
    # kableExtra::scroll_box(summarySta,width = "100%")
  }
  
}
```

<p>&nbsp;</p>

### Summary statistics

The following table allows you to verify some quality metrics (KPIs) for the different trait by environment combinations.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  staTraits <- setdiff( unique(modeling[which(modeling$analysisId == idSta),"trait"]), "inputObject")
  
  if("params" %in% ls()){ # we will download the document
    shinyjs::hide()
  }else{ # input <- list(traitSta=staTraits[1])
    
    shiny::selectInput(ns("traitSta"), 
                       label = "Trait to filter:", 
                       multiple = FALSE,
                       choices = staTraits, 
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  metricsSum <- result$metrics[which(result$metrics$analysisId == idSta),]
  pred.traits.summary <- reshape(metricsSum[,c("trait","environment","parameter","value")], direction = "wide", idvar = c("trait","environment"),
                                 timevar = "parameter", v.names = "value", sep= "_")
  colnames(pred.traits.summary) <- gsub("value_","", colnames(pred.traits.summary))
  numeric.output <- colnames(pred.traits.summary)[-c(1:2)]
  
  if("params" %in% ls()){ # we will download the document
    # printTable((pred.traits.summary), 'different')
    printTable(pred.traits.summary, autoWidthOpt = TRUE, scrollXOpt = FALSE,
             colNames = colnames(pred.traits.summary),
           numericColNames = intersect(colnames(colnames(pred.traits.summary)),numeric.output),
           numRound = 4)
  }else{
    DT::renderDT(printTable(pred.traits.summary[pred.traits.summary$trait==input$traitSta,],
                        autoWidthOpt = FALSE, scrollXOpt = TRUE,
                        colNames = colnames(pred.traits.summary[pred.traits.summary$trait==input$traitSta,]),
                        numericColNames = intersect(colnames(colnames(pred.traits.summary[pred.traits.summary$trait==input$traitSta,])),numeric.output),
                        numRound = 4), server = FALSE)
  }
  
}
```

<p>&nbsp;</p>

`r if (length(which( result$metadata$pheno$parameter %in% c("row","col") ))==2 ) {
coordNames <- result$metadata$pheno[result$metadata$pheno$parameter %in% c("row","col"),"value" ]
if( any( apply(result$data$pheno[,coordNames],2, sommer::propMissing) == 1) ){shinyjs::hide()}else{"### Field view\n
The following heatmaps allow you to inspect the spatial trends in the different fields to take corrective measures in the next season and understand why some variance components may look the way they look.\n"}
}`

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  traitFieldView <- unique(result$predictions[which( result$predictions$analysisId == idSta),"trait"])
  
  if("params" %in% ls()){ # we will download the document
    shinyjs::hide()
  }else{
    
    if(length(which( result$metadata$pheno$parameter %in% c("row","col") ))==2 ){ # user mapped the columns
      
      coordNames <- result$metadata$pheno[result$metadata$pheno$parameter %in% c("row","col"),"value" ]
      
      if( any( apply(result$data$pheno[,coordNames],2, sommer::propMissing) == 1) ){ # we can't proceed, there's no information in one of the coordinates
        shinyjs::hide()
      }else{ # input <- list(traitStaFieldView=traitFieldView[1])
        shiny::selectInput(ns("traitStaFieldView"), 
                           label = "Trait to filter:", 
                           choices = traitFieldView, 
        )
      }
      
    }
    
  }
  
}
```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  if(length(which( result$metadata$pheno$parameter %in% c("row","col") ))==2 ){
    
    
    if( any( apply(result$data$pheno[,coordNames],2, sommer::propMissing) == 1) ){ # we can't proceed, there's no information in one of the coordinates
      shinyjs::hide()
    }else{
      pheno <- result$data$pheno
      pheno <- pheno[,which(!duplicated(colnames(pheno)))]
      metaPheno <- result$metadata$pheno; metaPheno <- metaPheno[metaPheno$parameter != "trait", ]
      colnames(pheno) <- cgiarBase::replaceValues( colnames(pheno), Search = metaPheno$value, Replace = metaPheno$parameter)
      
      if("params" %in% ls()){ # we will download the document
        
        cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
        
        for(iTrait in traitFieldView){
          cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
          
          pheno$value <- pheno[, iTrait]
          maxVal <- max(pheno$value, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
          minVal <- min(pheno$value, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
          meanVal <- mean(pheno$value, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
          pheno$envLabel <- gsub("_", " ", pheno$environment)
          p <- ggplot2::ggplot(data = pheno, ggplot2::aes(row, col, fill = value))+
            ggplot2::geom_tile(color = "white")+
            ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "gold",
                                          midpoint = meanVal, limit = c(minVal,maxVal), space = "Lab",
                                          name=iTrait) +
            ggplot2::theme_minimal()+
            ggplot2::ylab("") + ggplot2::xlab("") +
            ggplot2::facet_wrap(~envLabel, scales = "free", labeller = labeller(envLabel = label_wrap_gen(width = 20))) +
            ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) # +
            # ggplot2::theme(panel.spacing.y = unit(5, "lines"))
          # print(p) # static
          print(htmltools::tagList(plotly::ggplotly(p))) # dynamic
          
        }
        
      }else{ # we will display in the GUI
        
        # shiny::renderPlot({ # static
        plotly::renderPlotly({ # dynamic
          
          pheno$value <- pheno[, input$traitStaFieldView]
          maxVal <- max(pheno$value, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
          minVal <- min(pheno$value, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
          meanVal <- mean(pheno$value, na.rm = TRUE) # get the maximum value found in the matrix of connectivity
          
          p <- ggplot2::ggplot(data = pheno, ggplot2::aes(row, col, fill = value))+
            ggplot2::geom_tile(color = "white")+
            ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "gold",
                                          midpoint = meanVal, limit = c(minVal,maxVal), space = "Lab",
                                          name=input$traitStaFieldView) +
            ggplot2::theme_minimal()+
            ggplot2::ylab("") + ggplot2::xlab("") +
            ggplot2::facet_wrap(~environment, scales = "free") +
            ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank() ) + ggplot2::theme(panel.spacing = unit(0, 'points'))
          plotly::ggplotly(p)
          
        })
        
      }
    } # end of if user has coordinate data
    
  } # end of if user mapped the coordinate columns
  
}

```

### Output parameters 

<p>&nbsp;</p>

This barplot allows you to see the variance components values and ratios for the trait by environment combinations and identify good quality trials.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  staTraits2 <- setdiff( unique(modeling[which(modeling$analysisId == idSta),"trait"]), "inputObject")
  
  if("params" %in% ls()){ # we will download the document
    shinyjs::hide()
  }else{
    shiny::selectInput(ns("traitSta0"), 
                       label = "Trait to filter:", 
                       multiple = FALSE,
                       choices = staTraits2, 
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  df2 <- result$metrics
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  df2 <- df2[df2$analysisId==idSta,]
  df2 <- df2[df2$parameter %in% c("Vr","Vg","V_designation","V_residual","V_repF","V_iBlockF","V_rowF","V_colF", "V_s(row, col)",
                                  apply(expand.grid( c("Vr","Vg","V_designation","V_mother","V_father","V_residual","V_repF","V_iBlockF","V_rowF","V_colF", "V_s(row, col)"), c("designation","mother","father")),1,function(f){paste(f,collapse = "_")})
  ), ]
  df2$type <- "designation"
  motherParams <- grep("mother", df2$parameter)
  if(length(motherParams) > 0){df2$type[motherParams]="mother"}
  fatherParams <- grep("father", df2$parameter)
  if(length(fatherParams) > 0){df2$type[fatherParams]="father"}
  
  total <- aggregate(value~environment+trait+type, FUN = sum, data=df2); 
  colnames(total)[4] <- "totalVar"
  df3 <- merge(df2,total, by=c("environment","trait","type") )
  df3$valueProp <- df3$value/df3$totalVar
  df3$parameter <- gsub("_designation","", df3$parameter)
  df3$parameter <- gsub("_mother","", df3$parameter)
  df3$parameter <- gsub("_father","", df3$parameter)
  df3$parameter[which(nchar(df3$parameter) == 1)] <- "V_genetics"
  
  if("params" %in% ls()){ # we will download the document
    
    cat("\n\n###  {.tabset .tabset-pills}       \n\n")
    
    for (j in 1:length(staTraits2)){
      cat("\n\n####", staTraits2[j], "{.tabset .tabset-pills}       \n\n")
      df4 <- df3[df3$trait == staTraits2[j],]
      p_proportion_variance <- ggplot2::ggplot(data=df4, ggplot2::aes(x=environment, y=valueProp, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        # ggplot2::scale_fill_brewer(palette="Accent") +
        ggplot2::theme(axis.text.x = ggplot2::element_blank()) +
        ggplot2::xlab("") + ggplot2::ylab("Proportion of variance") +
        ggplot2::facet_wrap(~type)
      p_value_variance <- ggplot2::ggplot(data=df4, ggplot2::aes(x=environment, y=value, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        # ggplot2::scale_fill_brewer(palette="Accent") +
        ggplot2::theme(axis.text.x = ggplot2::element_blank()) +
        ggplot2::guides(fill = "none") +
        ggplot2::xlab("Environment") + ggplot2::ylab("Variance") +
        ggplot2::facet_wrap(~type)
      
      print(htmltools::tagList( plotly::subplot(plotly::ggplotly(p_proportion_variance), plotly::ggplotly(p_value_variance), nrows=2, shareX = TRUE, shareY = TRUE) ) )
      
      cat("\n")
    }
    
    cat("\n")
    
  }else{
    
    plotly::renderPlotly({
      df4 <- df3[df3$trait == input$traitSta0,]
      p_proportion_variance <- ggplot2::ggplot(data=df4, ggplot2::aes(x=environment, y=valueProp, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        # ggplot2::scale_fill_brewer(palette="Accent") +
        ggplot2::theme(axis.text.x = ggplot2::element_blank()) +
        ggplot2::xlab("") + ggplot2::ylab("Proportion of variance") +
        ggplot2::facet_wrap(~type)
      p_value_variance <- ggplot2::ggplot(data=df4, ggplot2::aes(x=environment, y=value, fill=parameter)) +
        ggplot2::geom_bar(stat="identity") +
        # ggplot2::scale_fill_brewer(palette="Accent") +
        ggplot2::theme(axis.text.x = ggplot2::element_blank()) +
        ggplot2::guides(fill = "none") +
        ggplot2::xlab("Environment") + ggplot2::ylab("Variance") +
        ggplot2::facet_wrap(~type)
      p_proportion_variance <- plotly::ggplotly(p_proportion_variance)
      p_value_variance <- plotly::ggplotly(p_value_variance)
      plotly::subplot(p_proportion_variance, p_value_variance, nrows=2, shareX = FALSE, shareY = TRUE)
      
    })
  }
  
}
```

<p>&nbsp;</p>

```{r}
if (is.null(result)){
  # invisible(NULL)
} else {
  metrics <- result$metrics
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  parameters <- metrics[which(metrics$analysisId == idSta),"parameter"]
  if("params" %in% ls()){  # if user will download the report
    shinyjs::hide()
  }else{
    
    inputPanel(
      shiny::selectInput(ns("parameterMetrics"), 
                         label = "Parameter to filter:", 
                         multiple = FALSE,
                         selected = unique(parameters),
                         choices = unique(parameters)
      ),
      selectInput(ns("parameterMetricsBy"),
                  label = "View x-axis by:",
                  selected = "environment",
                  choices = c("environment","trait")
      ),
    )
    
    
  }
}
```
<p>&nbsp;</p>

The following barplot is designed to provide a high-level view of estimated parameters such as reliability, heritabiliy, coefficient of variation and others.

<p>&nbsp;</p>

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  mydata = result$metrics
  mydata <- mydata[which(mydata$analysisId %in% idSta),]
  
  if("params" %in% ls()){  # if user will download the report
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    counter <- 1
    
    for(iView in c("environment","trait") ){
      cat("\n\n####", iView, "{.tabset .tabset-pills}       \n\n")
      # for(iTrait in staTraits){
      for(iParam in unique(parameters)){
        cat("\n\n#####", iParam, "{.tabset .tabset-pills}       \n\n")
        mydata2 = mydata[which(mydata$parameter %in% iParam),]
        if(nrow(mydata2) > 0){
          if(iView == "environment"){
            number_rows <- ceiling(length(unique(mydata2$trait))/3) # 3 is the number of columns we want
            p <- ggplot2::ggplot(data=mydata2, aes(x=environment, y=value, fill=trait)) +
              ggplot2::geom_bar(stat="identity", position=position_dodge()) +
              ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") +
              ggplot2::labs(x="Environment", y="Parameter value") +
              facet_wrap(~trait, scales = "free_y", nrow = number_rows)
          }else{
            number_rows <- ceiling(length(unique(mydata2$environment))/3) # 3 is the number of columns we want
            p <- ggplot2::ggplot(data=mydata2, aes(x=trait, y=value, fill=environment)) +
              ggplot2::geom_bar(stat="identity", position=position_dodge()) +
              ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") +
              ggplot2::labs(x="trait", y="Parameter value") +
              facet_wrap(~environment, scales = "free_y", nrow = number_rows)
          }
          print(htmltools::tagList(plotly::ggplotly(p)))
        }
        
      }
      
      # combine plots
      # print(htmltools::tagList( plotly::subplot(plotly::ggplotly(p), plotly::ggplotly(p2), nrows=1, shareY = TRUE, shareX = TRUE ) ) )
      cat("\n")
      
    }
    
    cat("\n")
    
  }else{ # display in website
    
    plotly::renderPlotly({
      
      mydata2 = mydata[which(mydata$parameter %in% input$parameterMetrics),]
      number_rows <- ceiling(length(unique(mydata2$trait))/3) # 3 is the number of columns we want
      if(input$parameterMetricsBy == "trait"){
        number_rows <- ceiling(length(unique(mydata2$environment))/3) # 3 is the number of columns we want
        p <- ggplot2::ggplot(data=mydata2, aes(x=trait, y=value, fill=environment)) +
          ggplot2::geom_bar(stat="identity", position=position_dodge()) +
          ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") +
          ggplot2::labs(x="trait", y="Parameter value") +
          facet_wrap(~environment, scales = "free_y", nrow = number_rows)
      }else{
        number_rows <- ceiling(length(unique(mydata2$trait))/3) # 3 is the number of columns we want
        p <- ggplot2::ggplot(data=mydata2, aes(x=environment, y=value, fill=trait)) +
          ggplot2::geom_bar(stat="identity", position=position_dodge()) +
          ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") +
          ggplot2::labs(x="Environment", y="Parameter value") +
          facet_wrap(~trait, scales = "free_y", nrow = number_rows) 
      }
      plotly::ggplotly(p)
    })
    
  }
  
}
```

### Modeling parameters

This section aims to provide the modeling table for the analysis in order to keep track of which environments were used in the analysis, what was the final model used for each trait and other potentially important parameters for future reference.

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  modelingSta <- result$modeling[which(modeling$analysisId == idSta),]
  
  if("params" %in% ls()){ # we will download the document
    printTable(modelingSta, autoWidthOpt = TRUE, scrollXOpt = FALSE,
             colNames = colnames(modelingSta))
  }else{
    DT::renderDT(printTable(modelingSta,
                        autoWidthOpt = FALSE, scrollXOpt = TRUE,
                        colNames = colnames(modelingSta)), server = FALSE)
  }
  
}

```


### Predictions

The adjusted means in the following visuualizations are the result of fitting a experimental-design agnostic mixed model where everything that can be fitted will be fitted in order to remove as much spatial noise as possible. That means that if a trial has block and incomplete block information both will be fitted. If the trial has also row and column information it will also be fitted together with a spatial kernel (Rodriguez-Alvarez et al., 2018). These table of adjusted means will be used as input information for the multi-trial analysis. We recommend you to don't take any selection decision at this point and wait until the multi-trial analysis is fitted.

The following table allows you to check the trait by environment adjusted means for the different individuals in wide format.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  envs <- unique(result$predictions[which( result$predictions$analysisId == idSta),"environment"])
  
  if("params" %in% ls()){ # we will download the document
    shinyjs::hide()
  }else{
    shiny::selectInput(ns("envSta"), 
                       label = "Environment to filter:", 
                       choices = envs, 
    )
  }
  
}
```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  traits <- unique(pred$trait)
  predictions.designation <- subset(pred, select = c(trait,designation,environment,entryType,predictedValue))
  predictions.designation <- reshape(
    data=predictions.designation, 
    timevar = c("trait"), 
    idvar = c("environment","designation","entryType"), 
    direction="wide"
  )
  names(predictions.designation) <- c("designation","environment","entryType",traits)
  
  if("params" %in% ls()){ # we will download the document
    printTable(predictions.designation, autoWidthOpt = TRUE, scrollXOpt = FALSE,
             colNames = colnames(predictions.designation),
           numericColNames = traits,
           numRound = 4)
  }else{
    DT::renderDT(printTable(predictions.designation[predictions.designation$environment==input$envSta,],
                        autoWidthOpt = FALSE, scrollXOpt = TRUE,
                        colNames = colnames(predictions.designation[predictions.designation$environment==input$envSta,]),
                        numericColNames = traits,
                        numRound = 4), server = FALSE)
  }
  
}

```

<p>&nbsp;</p>

The following boxplot allows you to see the distribution of predicted values by trait (y-axis) in the different environments to double check that everything looks OK.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  modeling <- modeling[which(modeling$analysisId == idSta),"trait"]
  modeling <- setdiff(modeling, "inputObject")
  
  if("params" %in% ls()){ # we will download the document
    shinyjs::hide()
  }else{
    shiny::selectInput(ns("traitStaBox"), 
                       label = "Trait to filter:", 
                       multiple = FALSE,
                       selected = unique(modeling),
                       choices = unique(modeling), 
    )
  }
  
}

```

```{r, results='asis'}
predTrait <- result$predictions[which(result$predictions$analysisId == idSta),]

if("params" %in% ls()){ # we will download the document
  traits <- unique(modeling)
  cat("\n\n###  {.tabset .tabset-pills}       \n\n")
  
  for (j in 1:length(traits)){ # 
    cat("\n\n####", traits[j], "{.tabset .tabset-pills}       \n\n")
    
    p <- ggplot2::ggplot(predTrait[which(predTrait$trait %in% traits[j]),], ggplot2::aes(x=reorder(environment, -predictedValue), y=predictedValue, label=designation) ) + 
      # ggplot2::geom_jitter(position=ggplot2::position_jitter(width=0.3, height=0.2), ggplot2::aes(colour=environment), alpha=0.9) +
      ggplot2::geom_boxplot(alpha = 0.5, show.legend = FALSE, ggplot2::aes(fill=factor(environment))) +
      # ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black", face="bold"), 
      #                axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1), legend.position = "none") +
      ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") + 
      ggplot2::labs(x="", y="Trait value") #+ ggplot2::facet_grid(trait~., scales = "free") 
    # print(p) # static
    print(htmltools::tagList(ggplotly(  p  ))) # dynamic
    
    cat("\n")
  }
  
  cat("\n")
  
}else{
  
  # shiny::renderPlot({
  plotly::renderPlotly({
    if(length(input$traitStaBox) > 0){
      dd <- predTrait[which(predTrait$trait %in% input$traitStaBox),]
      p <- ggplot2::ggplot(dd, ggplot2::aes(x=reorder(environment, -predictedValue), y=predictedValue, label=designation) ) +
        # ggplot2::geom_jitter(position=ggplot2::position_jitter(width=0.3, height=0.2), ggplot2::aes(colour=environment), alpha=0.9) +
        ggplot2::geom_boxplot(alpha = 0.5, show.legend = FALSE, ggplot2::aes(fill=factor(environment))) +
        # ggplot2::theme(strip.text.x = ggplot2::element_text(size=9, color="black", face="bold"), axis.text.x = ggplot2::element_text(angle = 45, hjust=1, vjust = 1), legend.position = "none") +
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom") + 
        ggplot2::labs(x="", y="Trait value")
      # p
      plotly::ggplotly(p)
    }
  })
}

```

<p>&nbsp;</p>

### Per-environment merit estimates of top designations (entries)

In the following plot you can observe the comparison between the top 30 designations from each entry type category for the different traits. If a category has less than a 30 designations all individuals are displayed. This should allow you to identify the top designations in each environment. We would NOT recommend you to use this for selection of parents or products. Wait until you have the results of the multi-trial analysis and selection indices.

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  modeling <- modeling[which(modeling$analysisId == idSta),]
  
  traitsComp <- unique(setdiff(modeling$trait, "inputObject"))
  traitsCompEnv <- unique(setdiff(modeling$environment, "general"))
  
  if("params" %in% ls()){ # we will download the document
    shinyjs::hide()
  }else{
    inputPanel(
      shiny::selectInput(ns("traitStaComp"), 
                         label = "Trait to filter:", 
                         multiple = FALSE,
                         choices = traitsComp
      ),
      selectInput(ns("traitStaCompEnv"),
                  label = "Environment",
                  multiple = FALSE,
                  choices = traitsCompEnv
      ),
    )
    
    
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  predComp <- result$predictions[which(result$predictions$analysisId == idSta),]
  
  if("params" %in% ls()){ # we will download the document
    
    cat(paste0("###   {.tabset .tabset-pills}    \n\n  "))
    
    for(iTrait in traitsComp){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      for(iEnv in traitsCompEnv){
        cat("\n\n#####", iEnv, "{.tabset .tabset-pills}       \n\n")
        
        temp.predComp.box <- predComp[predComp$trait== iTrait,]
        temp.predComp.box <- temp.predComp.box[temp.predComp.box$environment== iEnv,]
        if(nrow(temp.predComp.box) > 0){
          temp.predComp.box$entryTypeSimple <- LETTERS[as.numeric(as.factor(temp.predComp.box$entryType))]
          
          ub <- max(temp.predComp.box$predictedValue + temp.predComp.box$stdError, na.rm = TRUE)
          lb <- min(temp.predComp.box$predictedValue - temp.predComp.box$stdError, na.rm = TRUE)
          p1 <- ggplot2::ggplot(temp.predComp.box, ggplot2::aes(x=reorder(entryType, -predictedValue), y=predictedValue) ) +
            ggplot2::geom_boxplot(alpha = 0.5, show.legend = TRUE, ggplot2::aes(colour=factor(entryType))) +
            ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom", legend.title = element_blank() ) + 
            ggplot2::labs(x="", y="Trait value") +  
            ggplot2::guides(colour = guide_legend(nrow = ceiling(length(unique(temp.predComp.box$entryType))/3) )) +  ggplot2::facet_grid(~environment) +
            ggplot2::scale_y_continuous(limits = c(lb,ub) ) 
          
          temp.predComp.box.list <- split(temp.predComp.box, temp.predComp.box$entryType)
          temp.predComp.box.list <- lapply(temp.predComp.box.list, function(x){
            y <- split(x, x$environment)
            
            bindByEnv <- lapply(y, function(z){
              z <- z[with(z, order(-predictedValue)), ]
              z <- z[1:min(c(nrow(z), 30)),]
              return(z)
            })
            
            res0 <- do.call(rbind, bindByEnv)
            
            return(res0)
          })
          temp.predComp.box2 <- do.call(rbind, temp.predComp.box.list)
          temp.predComp.box2$entryTypeSimple <- LETTERS[as.numeric(as.factor(temp.predComp.box2$entryType))]
          p2 <- ggplot2::ggplot(
            data = temp.predComp.box2,
            mapping = ggplot2::aes(
              x = reorder(designation, -predictedValue),
              y = predictedValue,
              col = entryType,
              text = paste(
                paste0('<br>', "designation: ", designation),
                paste0('<br>', "entry type: ", entryType),
                paste0('<br>', "predicted value: ", round(predictedValue, 4)),
                paste0('<br>', "standard error: ", round(stdError, 4)),
                # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ",
                #        round(predictedValue + CI, 2), ")")))) +
                paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ",
                       round(predictedValue + stdError, 4), ")")))) +
            ggplot2::theme_classic() +  ggplot2::geom_point() + 
            ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
                                                ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
                                   width = 0.10) +
            ggplot2::labs(title = "", x = "Designation", y = "Predicted value", col = "entry type") +
            ggplot2::theme(axis.text.x = ggplot2::element_blank(), 
                           # axis.text.x = element_text(angle = 45, vjust = 0.5, size = 7, face = "bold"), 
                           legend.position = "bottom", legend.title = element_blank() ) + ggplot2::facet_grid(~environment, scales = "free_x") +
            ggplot2::guides(colour = guide_legend(nrow = ceiling(length(unique(temp.predComp.box2$entryType))/3) )) +  ggplot2::scale_y_continuous(limits = c(lb,ub) ) 
          
          print(htmltools::tagList( plotly::subplot(plotly::ggplotly(p1), plotly::ggplotly(p2), nrows=2 ) ) )
          cat("\n")
          cat("\n")
        }
        
      }
      
    }
    
  }else{
    
    plotly::renderPlotly({
      
      temp.predComp.box <- predComp[predComp$trait== input$traitStaComp,]
      temp.predComp.box <- temp.predComp.box[temp.predComp.box$environment== input$traitStaCompEnv,]
      temp.predComp.box$entryTypeSimple <- LETTERS[as.numeric(as.factor(temp.predComp.box$entryType))]
      
      ub <- max(temp.predComp.box$predictedValue + temp.predComp.box$stdError, na.rm = TRUE)
      lb <- min(temp.predComp.box$predictedValue - temp.predComp.box$stdError, na.rm = TRUE)
      
      p1 <- ggplot2::ggplot(temp.predComp.box, ggplot2::aes(x=reorder(entryType, -predictedValue), y=predictedValue) ) +
        ggplot2::geom_boxplot(alpha = 0.5, show.legend = TRUE, ggplot2::aes(colour=factor(entryType))) +  ggplot2::facet_grid(~environment) +
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), legend.position = "bottom", legend.title = element_blank() ) + 
        ggplot2::labs(x="", y="Trait value") +  
        ggplot2::guides(colour = guide_legend(nrow = ceiling(length(unique(temp.predComp.box$entryType))/3) )) +  ggplot2::scale_y_continuous(limits = c(lb,ub) ) 
      
      temp.predComp.box.list <- split(temp.predComp.box, temp.predComp.box$entryType)
      temp.predComp.box.list <- lapply(temp.predComp.box.list, function(x){
        y <- split(x, x$environment)
        
        bindByEnv <- lapply(y, function(z){
          z <- z[with(z, order(-predictedValue)), ]
          z <- z[1:min(c(nrow(z), 30)),]
          return(z)
        })
        
        res0 <- do.call(rbind, bindByEnv)
        
        return(res0)
      })
      temp.predComp.box2 <- do.call(rbind, temp.predComp.box.list)
      temp.predComp.box2$entryTypeSimple <- LETTERS[as.numeric(as.factor(temp.predComp.box2$entryType))]
      p2 <- ggplot2::ggplot(
        data = temp.predComp.box2,
        mapping = ggplot2::aes(
          x = reorder(designation, -predictedValue),
          y = predictedValue,
          col = entryType,
          text = paste(
            paste0('<br>', "designation: ", designation),
            paste0('<br>', "entry type: ", entryType),
            paste0('<br>', "predicted value: ", round(predictedValue, 4)),
            paste0('<br>', "standard error: ", round(stdError, 4)),
            # paste0("<br>95% CI: (", round(predictedValue - CI, 2) , ", ",
            #        round(predictedValue + CI, 2), ")")))) +
            paste0("<br>predVal +- stdError: (", round(predictedValue - stdError, 2) , ", ",
                   round(predictedValue + stdError, 4), ")")))) +
        ggplot2::theme_classic() +  ggplot2::geom_point() +
        ggplot2::geom_errorbar(ggplot2::aes(ymax = predictedValue + stdError,
                                            ymin = predictedValue - stdError), position = ggplot2::position_dodge(0.5),
                               width = 0.10) + ggplot2::facet_grid(~environment, scales = "free_x") +
        ggplot2::labs(title = "", x = "Designation", y = "Predicted value", col = "entry type") +
        ggplot2::theme( axis.text.x = ggplot2::element_blank(), 
                        # axis.text.x = element_text(angle = 45, vjust = 0.5, size = 7, face = "bold"), 
                        legend.position = "bottom", legend.title = element_blank() ) +  
        ggplot2::guides(colour = guide_legend(nrow = ceiling(length(unique(temp.predComp.box2$entryType))/3) )) + 
        ggplot2::scale_y_continuous(limits = c(lb,ub) ) 
      
      ply1 <- plotly::ggplotly(p1)
      ply2 <- plotly::ggplotly(p2)
      plotly::subplot(ply1, ply2, nrows=2)#, widths = c(0.75,0.25))
      
    })
    
    
    
  }
}
```


### Correlation between environments

The following plot aims to show the correlation between BLUEs or BLUPs (depending on the parameter settings) among the different environments for the traits available in order to identify if there is one or more environments that do not align with the target population of environments (i.e., negatively correlated with the main cluster across most environments). You may want to exclude such environments from the multi-trial analysis (MTA) to ensure that selected designations in the MTA achieve genetic gain in the main cluster of environments.

<p>&nbsp;</p>

```{r }
if (is.null(result)){
  # invisible(NULL)
} else {
  modeling <- result$modeling
  idSta <- result$status[which(result$status$module == "sta"),"analysisId"];
  idSta <- idSta[length(idSta)]
  modeling <- modeling[which(modeling$analysisId == idSta),"trait"]
  modeling <- setdiff(modeling, "inputObject")
  
  if("params" %in% ls()){ # we will download the document
    shinyjs::hide()
  }else{
    shiny::selectInput(ns("traitStaCor"), 
                       label = "Trait to filter:", 
                       multiple = FALSE,
                       selected = unique(modeling),
                       choices = unique(modeling), 
    )
  }
  
}

```

```{r, results='asis'}
if (is.null(result)){
  # invisible(NULL)
} else {
  
  predictions.gcorrE <- subset(pred, select = c(trait,designation,environment,predictedValue))
  
  # addTextInPlots <- ifelse(length(envs) > 30, FALSE, TRUE)
  if("params" %in% ls()){ # we will download the document
    
    cat("\n\n###  {.tabset .tabset-pills}       \n\n")
    
    for(iTrait in traits){
      cat("\n\n####", iTrait, "{.tabset .tabset-pills}       \n\n")
      
      predictions.gcorrE2 <- predictions.gcorrE[predictions.gcorrE$trait == iTrait, ]
      wide <- stats::reshape(predictions.gcorrE2,
                             direction = "wide", idvar = "designation",
                             timevar = "environment", v.names = "predictedValue", sep= "")
      colnames(wide) <- gsub("predictedValue","",colnames(wide))
      wide2 <- as.data.frame(wide[,-c(1:2)]); colnames(wide2) <- colnames(wide)[-c(1:2)]
      corr <- round(stats::cor(wide2, use="pairwise.complete.obs"),2)
      if(nrow(corr) > 1){
        if( length(which(is.na(corr))) == 0){
          ord <- hclust( dist(corr, method = "euclidean"), method = "ward.D" )$order
          corr <- corr[ord,ord]
        }
        
      }
      vv <- cgiarBase::matToTab(corr)
      p <- ggplot2::ggplot(data = vv, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white", 
                                      midpoint = 0, limit = c(-1,1), space = "Lab", 
                                      name="Pearson\nCorrelation") +
        ggplot2::theme_minimal()+ 
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 8, hjust = 1))+
        # ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 8, hjust = 1))+
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) + 
        ggplot2::ylab("Environments") + ggplot2::xlab("Environments") +
        ggplot2::coord_fixed()
      # print(p)
      # Basic histogram
      vv$Group <- ifelse(vv$Freq < 0, "Low", ifelse(vv$Freq < 0.2, "Medium", "High"))
      group.colors <- c(Low="#E46726",Medium="white", High="#038542")
      p2 <- ggplot(vv[which(vv$Var1 != vv$Var2),], aes(x=Freq, fill=Group)) + 
        geom_histogram() + ggplot2::scale_x_continuous(limits = c(-1,1)) +
        scale_fill_manual(values=group.colors) + ggplot2::xlab("Value")
      # combine plots
      print(htmltools::tagList( plotly::subplot(plotly::ggplotly(p), plotly::ggplotly(p2), nrows=1, shareY = TRUE, shareX = TRUE ) ) )
      # print(htmltools::tagList(plotly::ggplotly(p)))
      cat("\n")
    }
    cat("\n")
    cat("\n")
  }else{
    
    # shiny::renderPlot({
    plotly::renderPlotly({
      predictions.gcorrE2 <- predictions.gcorrE[predictions.gcorrE$trait == input$traitStaCor, ]
      
      wide <- stats::reshape(predictions.gcorrE2,
                             direction = "wide", idvar = "designation",
                             timevar = "environment", v.names = "predictedValue", sep= "")
      colnames(wide) <- gsub("predictedValue","",colnames(wide))
      wide2 <- as.data.frame(wide[,-c(1:2)]); colnames(wide2) <- colnames(wide)[-c(1:2)]
      corr <- round(stats::cor(wide2, use="pairwise.complete.obs"),2)
      if(nrow(corr) > 1){
        if( length(which(is.na(corr))) == 0){
          ord <- hclust( dist(corr, method = "euclidean"), method = "ward.D" )$order
          corr <- corr[ord,ord]
        }
        
      }
      vv <- cgiarBase::matToTab(corr)
      p <- ggplot2::ggplot(data = vv, ggplot2::aes(Var2, Var1, fill = Freq))+
        ggplot2::geom_tile(color = "white")+
        ggplot2::scale_fill_gradient2(low = "#E46726", high = "#038542", mid = "white", 
                                      midpoint = 0, limit = c(-1,1), space = "Lab", 
                                      name="Pearson\nCorrelation") +
        ggplot2::theme_minimal()+ 
        # ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, size = 8, hjust = 1))+
        # ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0, vjust = 1, size = 8, hjust = 1))+
        ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) + 
        ggplot2::ylab("Environments") + ggplot2::xlab("Environments") +
        ggplot2::coord_fixed()
      # p
      # plotly::ggplotly(p)
      # Basic histogram
      vv$Group <- ifelse(vv$Freq < 0, "Low", ifelse(vv$Freq < 0.2, "Medium", "High"))
      group.colors <- c(Low="#E46726",Medium="white", High="#038542")
      p2 <- ggplot(vv[which(vv$Var1 != vv$Var2),], aes(x=Freq, fill=Group)) + 
        geom_histogram() + ggplot2::scale_x_continuous(limits = c(-1,1)) +
        scale_fill_manual(values=group.colors) + ggplot2::xlab("Correlation Value")
      # combine plots
      ply1 <- plotly::ggplotly(p)
      ply2 <- plotly::ggplotly(p2)
      plotly::subplot(ply1, ply2, nrows=1, shareY = TRUE, shareX = TRUE )
    })
    
    
  }
  
}
```


### References of methods used

Velazco, J. G., Rodriguez-Alvarez, M. X., Boer, M. P., Jordan, D. R., Eilers, P. H., Malosetti, M., & Van Eeuwijk, F. A. (2017). Modelling spatial trends in sorghum breeding field trials using a two-dimensional P-spline mixed model. Theoretical and Applied Genetics, 130, 1375-1392.

Rodriguez-Alvarez, M. X., Boer, M. P., van Eeuwijk, F. A., & Eilers, P. H. (2018). Correcting for spatial heterogeneity in plant breeding experiments with P-splines. Spatial Statistics, 23, 52-71.

R Core Team (2021). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

Boer M, van Rossum B (2022). LMMsolver: Linear Mixed Model Solver. R package version 1.0.4.9000.

<p>&nbsp;</p>

